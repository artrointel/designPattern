// 공통성과 가변성의분리
// 디자인 패턴의 핵심 1.
// 공통성과 가변성의 분리 : 변하지 않은 전체흐름에서 변하는것을
//					분리한다.

// 1. 변하는 것을 가상함수로 뽑아낸다.
//    => 상속을 통해서 가상함수를 재정의 하면 정책 변경가능
//    => 정책의 재사용성이 떨어지고, 실행시간 교체가 불가능하다
//    => "template method" ( DoImpl() )

// 2. 변하는 것을 다른 클래스로 뽑아낸다. - 정책 클래스
//    정책 클래스를 교체하는 2가지 기술
//
//    A. 인터페이스 기반으로 정책 클래스 설계
//       장점 : 실행시간 교체가능
//		 단점 : 가상함수 기반이므로 느리다.
//		 => "전략 패턴(Strategy)"
//
//    B. template 인자로 정책 클래스를 교체 할수 있게한다.
//       장점 : 정책 클래스를 인라인함수로 만들수 있다. 빠르다
//       단점 : 실행시간 교체는 불가능. 
//				컴파일 시간만 교체 가능(template 인자이므로)
//		=> "단위 전략(Policy Base)" C++ 진영만 사용


/*
day1 !!요약!!

1_thiscall
-> 클래스 내 this의 동작원리와 이를 활용하여 native lib.를 OOP lib.화 할 수 있다.

2_vtable
-> 가상함수의 원리와 바인딩을 이해한다. 가상함수 사용 시 default params.에 주의하자.

3_solid_template_method

LSP, OCP

LSP - 자식 인스턴스는 부모 인스턴스로 치환하여도 잘 동작하여야 한다.
자식 클래스는 부모가 정의한 규칙을 깨트려서는 안된다는 것을 의미한다. (엄격한 상속)
https://vandbt.tistory.com/41 (rectangle, square)

OCP - 클래스 설계 시 기능 확장에는 열려있고 수정에는 닫혀있어야 한다.

prototype - 자기자신 인스턴스를 복제하는 인터페이스 설계는 유용하다. (removed type check code!)

template method - 전체 흐름 중 변하는 부분은 가상함수화하여 자식클래스에게 제공한다.

strategy - 변하는 부분을 인터페이스(클래스)로 분리하자.

4_policybase (C++ only)

policybase(단위전략) - 변하는 부분은 템플릿화하자.


** Strategy 패턴과 Adapter 패턴의 차이?
두 패턴은 구조적으로 선언은 동일하나 사용이 다르다.
전략패턴은 상황(런타임)에 따라 객체의 정책 교체가 가능하다. 
그러나 어댑터는 객체의 생성 시점에 결정되며 상황에 따라 변하지 않아야 한다.

*/